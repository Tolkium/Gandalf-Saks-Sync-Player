<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gandalf Saks Sync Player</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #121212;
        color: white;
        text-align: center;
        padding: 20px;
    }
    input, button {
        font-size: 16px;
        padding: 5px;
        margin: 5px;
    }
    #status { margin-top: 10px; font-weight: bold; }
    #autoplayOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    #autoplayOverlay button {
        font-size: 20px;
        padding: 12px 24px;
        cursor: pointer;
    }
    #overlayContent { text-align: center; }
    #overlayText { font-size: 18px; margin-bottom: 12px; }
</style>
</head>
<body>

<h1>Gandalf Saks Sync Player</h1>

<div id="player"></div>

<div id="status">Loading...</div>


<div id="autoplayOverlay">
    <div id="overlayContent">
        <div id="overlayText">Tap to start</div>
        <button id="startPlayback">Tap to start</button>
    </div>
    </div>

<script>
    const urlParams = new URLSearchParams(location.search);
    // Free sync config via GetPantry (no signup, free). Override via URL: ?pantry=...&room=...
    const DEFAULT_PANTRY_ID = 'a7183995-e0b0-46b1-bcf0-c2119c005931';
    const DEFAULT_ROOM_ID = 'default-room';
    let pantryId = urlParams.get('pantry') || DEFAULT_PANTRY_ID;
    let roomId = urlParams.get('room') || DEFAULT_ROOM_ID;

    function nowMs() { return Date.now(); }
    let serverOffsetMs = 0; // serverTime ~= nowMs() + serverOffsetMs
    async function refreshServerTimeOffset(sampleCount = 5) {
        const offsets = [];
        for (let i = 0; i < sampleCount; i++) {
            try {
                const t0 = performance.now();
                // Hit pantry endpoint that should exist and return Date header
                const url = `https://getpantry.cloud/apiv1/pantry/${encodeURIComponent(pantryId)}`;
                const res = await fetch(url, { method: 'GET', cache: 'no-store' });
                const t1 = performance.now();
                const dateHeader = res.headers.get('Date');
                if (!dateHeader) continue;
                const serverDateMs = Date.parse(dateHeader);
                if (!isFinite(serverDateMs)) continue;
                const rtt = t1 - t0;
                const estimatedServerNow = serverDateMs + rtt / 2;
                const offset = estimatedServerNow - nowMs();
                offsets.push(offset);
            } catch {}
        }
        if (offsets.length > 0) {
            offsets.sort((a, b) => a - b);
            const median = offsets[Math.floor(offsets.length / 2)];
            serverOffsetMs = median;
        }
    }
    function nowServerMs() { return nowMs() + serverOffsetMs; }

    let player;
    let videoDurationSec = 0;
    let writeTicker = null;
    let readyForWrites = false;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            videoId: 'syZgEDz_R28',
            playerVars: {
                autoplay: 1,
                controls: 1,
                modestbranding: 1,
                loop: 1,
                playlist: 'syZgEDz_R28',
                rel: 0,
                playsinline: 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady() {
        // Mute to satisfy autoplay policies across devices/browsers
        try { player.mute(); } catch (e) {}
        // Ensure iframe allows autoplay
        try {
            player.getIframe().setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
        } catch (e) {}
        (async () => {
            document.getElementById("status").textContent = "Ready";
            try { videoDurationSec = player.getDuration() || 0; } catch (e) {}
            await syncFromRemoteOnce();
            attemptAutoplay();
            readyForWrites = true;
        })();
    }

    let hasInitialSynced = false;
    let pausedSinceLastPlay = false;
    let periodicSyncTimer = null;
    async function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            const isInitial = !hasInitialSynced;
            if (isInitial || pausedSinceLastPlay) {
                await syncFromRemoteOnce();
                hasInitialSynced = true;
                pausedSinceLastPlay = false;
                document.getElementById("status").textContent = isInitial ? "Synced on join" : "Resynced after resume";
            }
            hideOverlay();
            // Start write ticker while playing
            if (!writeTicker && pantryId && roomId && readyForWrites) {
                writeTicker = setInterval(writeNowStateThrottled, 5000);
            }
            if (!periodicSyncTimer) {
                periodicSyncTimer = setInterval(periodicSyncAdjust, 2000);
            }
        } else if (event.data === YT.PlayerState.PAUSED) {
            pausedSinceLastPlay = true;
            // Write a final paused state snapshot
            if (pantryId && roomId && readyForWrites) {
                writeNowStateThrottled(true);
            }
            if (writeTicker) { clearInterval(writeTicker); writeTicker = null; }
            if (periodicSyncTimer) { clearInterval(periodicSyncTimer); periodicSyncTimer = null; }
        } else if (event.data === YT.PlayerState.UNSTARTED) {
            // Some browsers report UNSTARTED if autoplay is blocked
            showOverlay();
        }
    }

    // Auto-connect with default/URL room; perform initial server time sync and state sync
    (async () => {
        await refreshServerTimeOffset(5);
        await syncFromRemoteOnce();
        document.getElementById('status').textContent = pantryId && roomId ? `Connected to room ${roomId}` : 'Disconnected from remote';
    })();

    // Autoplay helpers
    function isPlaying() {
        try { return player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING; } catch (e) { return false; }
    }
    function attemptAutoplay() {
        try { player.playVideo(); } catch (e) {}
        // If not playing shortly, show overlay for user gesture
        setTimeout(() => { if (!isPlaying()) showOverlay(); }, 1200);
    }
    function showOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'flex';
    }
    function hideOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'none';
    }
    document.getElementById('startPlayback').addEventListener('click', () => {
        hideOverlay();
        try { player.playVideo(); } catch (e) {}
    });

    // UTC link-based sync and countdown removed for minimal setup

    // ---------- Free API (GetPantry) state sync ----------
    function pantryBasketUrl() {
        if (!pantryId || !roomId) return null;
        return `https://getpantry.cloud/apiv1/pantry/${encodeURIComponent(pantryId)}/basket/${encodeURIComponent(roomId)}`;
    }

    async function getSharedState() {
        const url = pantryBasketUrl();
        if (!url) return null;
        try {
            const res = await fetch(url, { method: 'GET', cache: 'no-store' });
            if (!res.ok) return null;
            return await res.json();
        } catch {
            return null;
        }
    }

    async function setSharedState(state) {
        const url = pantryBasketUrl();
        if (!url) return false;
        try {
            const res = await fetch(url, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state) });
            return res.ok;
        } catch {
            return false;
        }
    }

    function computeDerivedPosition(remote) {
        if (!remote) return null;
        const base = Number(remote.positionSec) || 0;
        const updatedAt = Number(remote.updatedAtServerMs || remote.updatedAtMs) || 0;
        const wasPlaying = !!remote.isPlaying;
        let derived = base;
        if (wasPlaying && updatedAt > 0) {
            const deltaSec = Math.max(0, (nowServerMs() - updatedAt) / 1000);
            derived = base + deltaSec;
        }
        if (videoDurationSec > 0) {
            derived = Math.min(derived, videoDurationSec - 0.25);
        }
        return derived;
    }

    async function syncFromRemoteOnce() {
        const remote = await getSharedState();
        if (!remote) return;
        const target = computeDerivedPosition(remote);
        if (target == null) return;
        try { player.seekTo(target, true); } catch (e) {}
    }

    async function periodicSyncAdjust() {
        const remote = await getSharedState();
        if (!remote) return;
        const target = computeDerivedPosition(remote);
        if (target == null) return;
        let current = 0;
        try { current = player.getCurrentTime ? player.getCurrentTime() : 0; } catch (e) { current = 0; }
        const drift = Math.abs(current - target);
        if (drift > 0.25) {
            try { player.seekTo(target, true); } catch (e) {}
            document.getElementById('status').textContent = `Corrected drift (${drift.toFixed(2)}s)`;
        }
    }

    let lastWriteMs = 0;
    async function writeNowStateThrottled(force = false) {
        if (!readyForWrites || !pantryId || !roomId) return;
        const now = Date.now();
        if (!force && now - lastWriteMs < 2000) return;
        lastWriteMs = now;
        try {
            const isPlaying = player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING;
            const positionSec = player.getCurrentTime ? player.getCurrentTime() : 0;
            const state = {
                videoId: 'syZgEDz_R28',
                positionSec,
                isPlaying,
                updatedAtMs: nowMs(),
                updatedAtServerMs: nowServerMs()
            };
            await setSharedState(state);
        } catch {}
    }

    let tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.body.appendChild(tag);
</script>

</body>
</html>
