<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gandalf Saks Sync Player</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #121212;
        color: white;
        text-align: center;
        padding: 20px;
    }
    input, button {
        font-size: 16px;
        padding: 5px;
        margin: 5px;
    }
    #status {
        margin-top: 10px;
        font-weight: bold;
    }
    #debug {
        margin-top: 20px;
        font-size: 14px;
        color: #ccc;
        text-align: left;
        display: inline-block;
    }
    #autoplayOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    #autoplayOverlay button {
        font-size: 20px;
        padding: 12px 24px;
        cursor: pointer;
    }
    #overlayContent { text-align: center; }
    #overlayText { font-size: 18px; margin-bottom: 12px; }
</style>
</head>
<body>

<h1>Gandalf Saks Sync Player</h1>

    <div>
        Loop length (ms): 
        <input type="number" id="loopLength" value="7500" min="100" step="50">
        <button id="saveSettings">Save</button>
    </div>

    <div style="margin-top:10px;">
        <input type="text" id="pantryId" placeholder="Pantry ID (getpantry.cloud)" style="width:40%;">
        <input type="text" id="roomId" placeholder="Room / basket name" style="width:30%;">
        <button id="connectRoom">Connect free sync</button>
    </div>

<div id="player"></div>

<div id="status">Loading...</div>

<div id="debug"></div>

<div id="autoplayOverlay">
    <div id="overlayContent">
        <div id="overlayText">Tap to start</div>
        <button id="startPlayback">Tap to start</button>
    </div>
    </div>

<div style="margin-top:10px;">
    <button id="makeLink">Create sync link (start in 5s)</button>
    <input id="shareLink" style="width:80%;" readonly>
    </div>

<script>
    const urlParams = new URLSearchParams(location.search);
    const GLOBAL_START_TIME = new Date("2025-01-01T00:00:00Z").getTime();
    let loopLengthMs = Number(urlParams.get('len')) || Number(localStorage.getItem("loopLengthMs")) || 7500;
    const SESSION_START_TIME_MS = Number(urlParams.get('t0')) || GLOBAL_START_TIME;

    // Free sync config via GetPantry (no signup, free). You can also pass via URL: ?pantry=...&room=...
    const DEFAULT_PANTRY_ID = 'a7183995-e0b0-46b1-bcf0-c2119c005931';
    let pantryId = urlParams.get('pantry') || localStorage.getItem('pantryId') || DEFAULT_PANTRY_ID;
    let roomId = urlParams.get('room') || localStorage.getItem('roomId') || '';

    // Maintain an offset between server clock and client clock so all devices
    // use a common time reference regardless of local clock skew.
    let serverTimeOffsetMs = 0; // server_now_ms - client_now_ms

    async function fetchServerDateHead() {
        const t0 = Date.now();
        const res = await fetch(location.href + (location.href.includes('?') ? '&' : '?') + 'nocache=' + Math.random(), {
            method: 'HEAD',
            cache: 'no-store'
        });
        const t2 = Date.now();
        const dateHeader = res.headers.get('Date');
        if (!dateHeader) return null;
        const serverNow = new Date(dateHeader).getTime();
        const clientMid = (t0 + t2) / 2;
        return { offset: serverNow - clientMid };
    }

    async function refreshServerTimeOffset(samples = 5) {
        try {
            const offsets = [];
            for (let i = 0; i < samples; i += 1) {
                const res = await fetchServerDateHead();
                if (res) offsets.push(res.offset);
                await new Promise(r => setTimeout(r, 60));
            }
            if (offsets.length) {
                offsets.sort((a,b)=>a-b);
                const mid = Math.floor(offsets.length/2);
                serverTimeOffsetMs = offsets.length % 2 === 1 ? offsets[mid] : Math.round((offsets[mid-1]+offsets[mid])/2);
            }
        } catch (e) {
            // Leave previous offset
        }
    }

    function nowMs() {
        return Date.now() + serverTimeOffsetMs;
    }

    let player;
    let videoDurationSec = 0;
    let writeTicker = null;
    let readyForWrites = false;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            videoId: 'syZgEDz_R28',
            playerVars: {
                autoplay: 1,
                controls: 1,
                modestbranding: 1,
                loop: 1,
                playlist: 'syZgEDz_R28',
                rel: 0,
                playsinline: 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady() {
        // Mute to satisfy autoplay policies across devices/browsers
        try { player.mute(); } catch (e) {}
        // Ensure iframe allows autoplay
        try {
            player.getIframe().setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
        } catch (e) {}
        (async () => {
            await refreshServerTimeOffset(5);
            // If session start is in the future, show countdown and start then
            const until = SESSION_START_TIME_MS - nowMs();
            if (until > 500) {
                startCountdownTo(SESSION_START_TIME_MS);
                try { player.pauseVideo(); } catch (e) {}
            } else {
                attemptAutoplay();
            }
            document.getElementById("status").textContent = "Ready";
            // Cache duration
            try { videoDurationSec = player.getDuration() || 0; } catch (e) {}
            // If pantry/room configured, do an initial fetch to align before first play if needed
            if (pantryId && roomId) {
                try { await syncFromRemoteOnce(); } catch (e) {}
            }
            readyForWrites = true;
        })();
    }

    let hasInitialSynced = false;
    let pausedSinceLastPlay = false;
    async function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            const isInitial = !hasInitialSynced;
            if (isInitial || pausedSinceLastPlay) {
                await refreshServerTimeOffset();
                // Prefer remote shared state if configured; otherwise use UTC-based ideal
                if (pantryId && roomId) {
                    await syncFromRemoteOnce();
                } else {
                    const ideal = getIdealPosition();
                    try { player.seekTo(ideal, true); } catch (e) {}
                }
                hasInitialSynced = true;
                pausedSinceLastPlay = false;
                document.getElementById("status").textContent = isInitial ? "Synced on join" : "Resynced after resume";
                document.getElementById("debug").innerHTML =
                    `<strong>Loop length:</strong> ${loopLengthMs} ms<br>` +
                    (pantryId && roomId ? `<strong>Remote room:</strong> ${roomId}<br>` : '') +
                    `<strong>Server offset:</strong> ${serverTimeOffsetMs.toFixed(0)} ms`;
            }
            hideOverlay();
            // Start write ticker while playing
            if (!writeTicker && pantryId && roomId && readyForWrites) {
                writeTicker = setInterval(writeNowStateThrottled, 5000);
            }
        } else if (event.data === YT.PlayerState.PAUSED) {
            pausedSinceLastPlay = true;
            // Write a final paused state snapshot
            if (pantryId && roomId && readyForWrites) {
                writeNowStateThrottled(true);
            }
            if (writeTicker) { clearInterval(writeTicker); writeTicker = null; }
        } else if (event.data === YT.PlayerState.UNSTARTED) {
            // Some browsers report UNSTARTED if autoplay is blocked
            showOverlay();
        }
    }

    function getIdealPosition() {
        const now = nowMs();
        const elapsed = (now - SESSION_START_TIME_MS) % loopLengthMs;
        return elapsed / 1000;
    }

    // No periodic drift correction. New visitors sync once on start; existing
    // viewers are not resynchronized.

    document.getElementById("saveSettings").addEventListener("click", () => {
        const val = parseInt(document.getElementById("loopLength").value);
        if (!isNaN(val) && val > 100) {
            loopLengthMs = val;
            localStorage.setItem("loopLengthMs", loopLengthMs);
        }
    });

    document.getElementById("loopLength").value = loopLengthMs;

    // Initialize free sync inputs
    const pantryEl = document.getElementById('pantryId');
    const roomEl = document.getElementById('roomId');
    pantryEl.value = pantryId;
    roomEl.value = roomId;
    document.getElementById('connectRoom').addEventListener('click', () => {
        pantryId = pantryEl.value.trim();
        roomId = roomEl.value.trim();
        localStorage.setItem('pantryId', pantryId);
        localStorage.setItem('roomId', roomId);
        document.getElementById('status').textContent = pantryId && roomId ? `Connected to room ${roomId}` : 'Disconnected from remote';
        // Pull current shared state immediately on connect
        if (pantryId && roomId) {
            (async () => {
                await refreshServerTimeOffset(3);
                await syncFromRemoteOnce();
            })();
        }
    });

    // Kick off server time sync once; periodic refresh optional but harmless
    refreshServerTimeOffset(5);

    // Autoplay helpers
    function isPlaying() {
        try { return player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING; } catch (e) { return false; }
    }
    function attemptAutoplay() {
        try { player.playVideo(); } catch (e) {}
        // If not playing shortly, show overlay for user gesture
        setTimeout(() => { if (!isPlaying()) showOverlay(); }, 1200);
    }
    function showOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'flex';
    }
    function hideOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'none';
    }
    document.getElementById('startPlayback').addEventListener('click', () => {
        hideOverlay();
        try { player.playVideo(); } catch (e) {}
    });

    function startCountdownTo(targetMs) {
        showOverlay();
        const btn = document.getElementById('startPlayback');
        const txt = document.getElementById('overlayText');
        if (btn) btn.style.display = 'none';
        let timer = null;
        const tick = () => {
            const remaining = Math.max(0, targetMs - nowMs());
            if (txt) txt.textContent = `Starting in ${(remaining/1000).toFixed(1)}s`;
            if (remaining <= 60) {
                clearInterval(timer);
                hideOverlay();
                try { player.playVideo(); } catch (e) {}
            }
        };
        tick();
        timer = setInterval(tick, 100);
    }

    document.getElementById('makeLink').addEventListener('click', async () => {
        await refreshServerTimeOffset(5);
        const now = nowMs();
        // target ~5s ahead aligned to next second
        const target = Math.ceil((now + 5000) / 1000) * 1000;
        const base = location.origin + location.pathname;
        const url = `${base}?t0=${Math.round(target)}&len=${loopLengthMs}` + (pantryId?`&pantry=${encodeURIComponent(pantryId)}`:'') + (roomId?`&room=${encodeURIComponent(roomId)}`:'');
        const input = document.getElementById('shareLink');
        input.value = url;
        try { await navigator.clipboard.writeText(url); } catch (e) {}
        document.getElementById("status").textContent = "Sync link copied (starts in ~5s)";
    });

    // ---------- Free API (GetPantry) state sync ----------
    function pantryBasketUrl() {
        if (!pantryId || !roomId) return null;
        return `https://getpantry.cloud/apiv1/pantry/${encodeURIComponent(pantryId)}/basket/${encodeURIComponent(roomId)}`;
    }

    async function getSharedState() {
        const url = pantryBasketUrl();
        if (!url) return null;
        try {
            const res = await fetch(url, { method: 'GET', cache: 'no-store' });
            if (!res.ok) return null;
            return await res.json();
        } catch {
            return null;
        }
    }

    async function setSharedState(state) {
        const url = pantryBasketUrl();
        if (!url) return false;
        try {
            const res = await fetch(url, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(state) });
            return res.ok;
        } catch {
            return false;
        }
    }

    function computeDerivedPosition(remote) {
        if (!remote) return null;
        const base = Number(remote.positionSec) || 0;
        const updatedAt = Number(remote.updatedAtMs) || 0;
        const wasPlaying = !!remote.isPlaying;
        let derived = base;
        if (wasPlaying && updatedAt > 0) {
            const deltaSec = Math.max(0, (nowMs() - updatedAt) / 1000);
            derived = base + deltaSec;
        }
        if (videoDurationSec > 0) {
            derived = Math.min(derived, videoDurationSec - 0.25);
        }
        return derived;
    }

    async function syncFromRemoteOnce() {
        const remote = await getSharedState();
        if (!remote) return;
        const target = computeDerivedPosition(remote);
        if (target == null) return;
        try { player.seekTo(target, true); } catch (e) {}
    }

    let lastWriteMs = 0;
    async function writeNowStateThrottled(force = false) {
        if (!readyForWrites || !pantryId || !roomId) return;
        const now = Date.now();
        if (!force && now - lastWriteMs < 2000) return;
        lastWriteMs = now;
        try {
            const isPlaying = player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING;
            const positionSec = player.getCurrentTime ? player.getCurrentTime() : 0;
            const state = {
                videoId: 'syZgEDz_R28',
                positionSec,
                isPlaying,
                updatedAtMs: nowMs(),
                loopLengthMs
            };
            await setSharedState(state);
        } catch {}
    }

    let tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.body.appendChild(tag);
</script>

</body>
</html>
