<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gandalf Saks Sync Player</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #121212;
        color: white;
        text-align: center;
        padding: 20px;
    }
    input, button {
        font-size: 16px;
        padding: 5px;
        margin: 5px;
    }
    #status { margin-top: 10px; font-weight: bold; }
    #autoplayOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    #autoplayOverlay button {
        font-size: 20px;
        padding: 12px 24px;
        cursor: pointer;
    }
    #overlayContent { text-align: center; }
    #overlayText { font-size: 18px; margin-bottom: 12px; }
</style>
</head>
<body>

<h1>Gandalf Saks Sync Player</h1>

<div id="player"></div>

<div id="status">Loading...</div>


<div id="autoplayOverlay">
    <div id="overlayContent">
        <div id="overlayText">Tap to start</div>
        <button id="startPlayback">Tap to start</button>
    </div>
    </div>

<script>
    const urlParams = new URLSearchParams(location.search);
    // Optional UTC anchor and period overrides for deterministic alignment across reloads
    let anchorMs = (() => {
        const t0 = urlParams.get('t0');
        if (!t0) return 0;
        const n = Number(t0);
        if (Number.isFinite(n)) return n;
        const p = Date.parse(t0);
        return Number.isFinite(p) ? p : 0;
    })();
    let periodSecParam = (() => {
        const pms = urlParams.get('periodMs');
        const ps = urlParams.get('period');
        if (pms && Number.isFinite(Number(pms))) return Number(pms) / 1000;
        if (ps && Number.isFinite(Number(ps))) return Number(ps);
        return null;
    })();
    // Stateless UTC-based sync (no backend, no CORS):
    // All clients compute the same position from a shared UTC clock.
    function nowMs() { return Date.now(); }
    let utcOffsetMs = 0; // world UTC ~= nowMs() + utcOffsetMs
    async function refreshUtcOffset(sampleCount = 7) {
        let best = null; // {offset, rtt}
        for (let i = 0; i < sampleCount; i++) {
            try {
                const t0 = performance.now();
                const res = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC', { cache: 'no-store' });
                const t1 = performance.now();
                if (!res.ok) continue;
                const data = await res.json();
                const serverUtcMs = (data.unixtime || Math.floor(Date.parse(data.utc_datetime) / 1000)) * 1000;
                const rtt = t1 - t0;
                const estimatedServerNow = serverUtcMs + rtt / 2;
                const offset = estimatedServerNow - nowMs();
                if (!best || rtt < best.rtt) best = { offset, rtt };
            } catch {}
        }
        if (best) {
            // Smooth to avoid sudden jumps
            utcOffsetMs = 0.8 * utcOffsetMs + 0.2 * best.offset;
        }
    }
    function nowUtcMs() { return nowMs() + utcOffsetMs; }
    // Periodically refine UTC offset to reduce drift (tolerant to failures)
    setInterval(() => { try { refreshUtcOffset(3); } catch (e) {} }, 120000);

    let player;
    let videoDurationSec = 0;
    let writeTicker = null;
    let readyForWrites = false;
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            videoId: 'syZgEDz_R28',
            playerVars: {
                autoplay: 1,
                controls: 1,
                modestbranding: 1,
                loop: 1,
                playlist: 'syZgEDz_R28',
                rel: 0,
                playsinline: 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady() {
        // Mute to satisfy autoplay policies across devices/browsers
        try { player.mute(); } catch (e) {}
        // Ensure iframe allows autoplay
        try {
            player.getIframe().setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
        } catch (e) {}
        (async () => {
            document.getElementById("status").textContent = "Ready";
            try { videoDurationSec = player.getDuration() || 0; } catch (e) {}
            try { await refreshUtcOffset(1); } catch (e) {}
            try { syncToTarget(true); } catch (e) {}
            attemptAutoplay();
            readyForWrites = true;
        })();
    }

    let hasInitialSynced = false;
    let pausedSinceLastPlay = false;
    let periodicSyncTimer = null;
    const SYNC_INTERVAL_MS = 200;
    const PAUSE_MIN_SEC = 0.01;      // use pause/resume above 10ms when ahead
    const DRIFT_THRESHOLD_SEC = 0.25; // seek if beyond this and not using pause
    const MAJOR_DRIFT_SEC = 0.7;      // always correct immediately via seek
    const CORRECTION_COOLDOWN_MS = 1200;
    let lastCorrectionAt = 0;
    let pausePending = false;
    let pauseResumeRaf = 0;
    async function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            const isInitial = !hasInitialSynced;
            if (isInitial || pausedSinceLastPlay) {
                syncToTarget(true);
                hasInitialSynced = true;
                pausedSinceLastPlay = false;
                document.getElementById("status").textContent = isInitial ? "Synced on join" : "Resynced after resume";
            }
            hideOverlay();
            if (!periodicSyncTimer) {
                periodicSyncTimer = setInterval(periodicSyncAdjust, SYNC_INTERVAL_MS);
            }
        } else if (event.data === YT.PlayerState.PAUSED) {
            pausedSinceLastPlay = true;
            if (periodicSyncTimer) { clearInterval(periodicSyncTimer); periodicSyncTimer = null; }
        } else if (event.data === YT.PlayerState.UNSTARTED) {
            // Some browsers report UNSTARTED if autoplay is blocked
            showOverlay();
        }
    }

    // Initial world time sync
    (async () => {
        await refreshUtcOffset(6);
    })();

    // Autoplay helpers
    function isPlaying() {
        try { return player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING; } catch (e) { return false; }
    }
    function attemptAutoplay() {
        try { player.playVideo(); } catch (e) {}
        // If not playing shortly, show overlay for user gesture
        setTimeout(() => { if (!isPlaying()) showOverlay(); }, 1200);
    }
    function showOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'flex';
    }
    function hideOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'none';
    }
    document.getElementById('startPlayback').addEventListener('click', () => {
        hideOverlay();
        try { player.playVideo(); } catch (e) {}
    });

    // UTC link-based sync and countdown removed for minimal setup

    // Stateless, UTC-based target and periodic drift correction
    function effectiveUtcMs() { return nowUtcMs(); }
    function computeUtcTargetPositionSec() {
        const dur = Number(periodSecParam || videoDurationSec) || 0;
        if (dur <= 0) return 0;
        const pos = ((effectiveUtcMs() - anchorMs) / 1000) % dur;
        return Math.max(0, Math.min(dur - 0.2, pos));
    }
    function syncToTarget(force = false) {
        const target = computeUtcTargetPositionSec();
        let current = 0;
        try { current = player.getCurrentTime ? player.getCurrentTime() : 0; } catch (e) { current = 0; }
        const drift = target - current; // signed seconds (positive => behind)
        const absDrift = Math.abs(drift);
        const nowTs = performance.now();
        const recentlyCorrected = (nowTs - lastCorrectionAt) < CORRECTION_COOLDOWN_MS;

        // Major corrections: single seek
        if (force || absDrift >= MAJOR_DRIFT_SEC || (!recentlyCorrected && absDrift >= DRIFT_THRESHOLD_SEC)) {
            try { player.seekTo(target, true); } catch (e) {}
            lastCorrectionAt = nowTs;
            if (!force) document.getElementById('status').textContent = `Corrected drift (${absDrift.toFixed(3)}s)`;
            return;
        }

        // If ahead (current > target), pause until target catches up to current
        if (!recentlyCorrected && drift < -PAUSE_MIN_SEC && !pausePending) {
            pauseUntilCatchUp(-drift);
            lastCorrectionAt = nowTs;
            return;
        }
        // If behind a bit, do a tiny forward seek to the target
        if (!recentlyCorrected && drift > PAUSE_MIN_SEC) {
            try { player.seekTo(target, true); } catch (e) {}
            lastCorrectionAt = nowTs;
            document.getElementById('status').textContent = `Corrected drift (${absDrift.toFixed(3)}s)`;
            return;
        }
    }
    function pauseUntilCatchUp(waitSec) {
        pausePending = true;
        try { player.pauseVideo(); } catch (e) {}
        const resumeAtUtcMs = nowUtcMs() + waitSec * 1000;
        // Coarse timer then fine rAF spin to hit within ~10-20ms
        const coarseDelay = Math.max(0, waitSec * 1000 - 40);
        setTimeout(() => {
            const step = () => {
                if (nowUtcMs() >= resumeAtUtcMs - 5) {
                    try { player.playVideo(); } catch (e) {}
                    pausePending = false;
                    if (pauseResumeRaf) cancelAnimationFrame(pauseResumeRaf);
                    pauseResumeRaf = 0;
                } else {
                    pauseResumeRaf = requestAnimationFrame(step);
                }
            };
            pauseResumeRaf = requestAnimationFrame(step);
        }, coarseDelay);
    }
    function periodicSyncAdjust() { syncToTarget(false); }

    // No shared state writes; synchronization is derived from UTC

    let tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.body.appendChild(tag);
</script>

</body>
</html>
