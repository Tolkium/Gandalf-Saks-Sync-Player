<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gandalf Saks Sync Player</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #121212;
        color: white;
        text-align: center;
        padding: 20px;
    }
    input, button {
        font-size: 16px;
        padding: 5px;
        margin: 5px;
    }
    #status { margin-top: 10px; font-weight: bold; }
    #autoplayOverlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    }
    #autoplayOverlay button {
        font-size: 20px;
        padding: 12px 24px;
        cursor: pointer;
    }
    #overlayContent { text-align: center; }
    #overlayText { font-size: 18px; margin-bottom: 12px; }
</style>
</head>
<body>

<h1>Gandalf Saks Sync Player</h1>

<div id="player"></div>

<div id="status">Loading...</div>


<div id="autoplayOverlay">
    <div id="overlayContent">
        <div id="overlayText">Tap to start</div>
        <button id="startPlayback">Tap to start</button>
    </div>
    </div>

<script>
    const urlParams = new URLSearchParams(location.search);
    const mode = (urlParams.get('mode') || 'yt').toLowerCase(); // 'yt' or 'native'
    const nativeSrc = urlParams.get('src') || '';
    // Optional UTC anchor and period overrides for deterministic alignment across reloads
    let anchorMs = (() => {
        const t0 = urlParams.get('t0');
        if (!t0) return 0;
        const n = Number(t0);
        if (Number.isFinite(n)) return n;
        const p = Date.parse(t0);
        return Number.isFinite(p) ? p : 0;
    })();
    let periodSecParam = (() => {
        const pms = urlParams.get('periodMs');
        const ps = urlParams.get('period');
        if (pms && Number.isFinite(Number(pms))) return Number(pms) / 1000;
        if (ps && Number.isFinite(Number(ps))) return Number(ps);
        return null;
    })();
    // Stateless UTC-based sync (no backend, no CORS):
    // All clients compute the same position from a shared UTC clock.
    function nowMs() { return Date.now(); }
    let utcOffsetMs = 0; // world UTC ~= nowMs() + utcOffsetMs
    async function fetchUtcFromWorldtimeapi() {
        const t0 = performance.now();
        const res = await fetch('https://worldtimeapi.org/api/timezone/Etc/UTC', { cache: 'no-store' });
        const t1 = performance.now();
        if (!res.ok) throw new Error('wta not ok');
        const data = await res.json();
        const serverUtcMs = (data.unixtime || Math.floor(Date.parse(data.utc_datetime) / 1000)) * 1000;
        const rtt = t1 - t0;
        return { estimatedUtcMs: serverUtcMs + rtt / 2, rtt };
    }
    async function fetchUtcFromTimeapiIo() {
        const t0 = performance.now();
        const res = await fetch('https://www.timeapi.io/api/Time/current/zone?timeZone=UTC', { cache: 'no-store' });
        const t1 = performance.now();
        if (!res.ok) throw new Error('timeapi not ok');
        const data = await res.json();
        const serverUtcMs = Date.parse(data.dateTime + 'Z');
        const rtt = t1 - t0;
        return { estimatedUtcMs: serverUtcMs + rtt / 2, rtt };
    }
    async function fetchUtcFromSelfDateHeader() {
        const t0 = performance.now();
        const res = await fetch(location.href, { method: 'GET', cache: 'no-store' });
        const t1 = performance.now();
        const dateHeader = res.headers.get('Date');
        if (!dateHeader) throw new Error('no date hdr');
        const serverUtcMs = Date.parse(dateHeader);
        const rtt = t1 - t0;
        return { estimatedUtcMs: serverUtcMs + rtt / 2, rtt };
    }
    async function refreshUtcOffset(samplesPerSource = 2) {
        const results = [];
        for (let i = 0; i < samplesPerSource; i++) {
            try { results.push(await fetchUtcFromWorldtimeapi()); } catch {}
            try { results.push(await fetchUtcFromTimeapiIo()); } catch {}
            try { results.push(await fetchUtcFromSelfDateHeader()); } catch {}
        }
        if (results.length === 0) return;
        results.sort((a, b) => a.rtt - b.rtt);
        const best = results[0];
        const newOffset = best.estimatedUtcMs - nowMs();
        // Smooth to avoid jumps
        utcOffsetMs = 0.85 * utcOffsetMs + 0.15 * newOffset;
    }
    function nowUtcMs() { return nowMs() + utcOffsetMs; }
    // Periodically refine UTC offset to reduce drift (tolerant to failures)
    setInterval(() => { try { refreshUtcOffset(3); } catch (e) {} }, 120000);

    let player;
    let videoDurationSec = 0;
    let writeTicker = null;
    let readyForWrites = false;
    function onYouTubeIframeAPIReady() {
        if (mode !== 'yt') return; // ignore if using native
        player = new YT.Player('player', {
            videoId: 'syZgEDz_R28',
            playerVars: {
                autoplay: 1,
                controls: 1,
                modestbranding: 1,
                loop: 1,
                playlist: 'syZgEDz_R28',
                rel: 0,
                playsinline: 1
            },
            events: {
                'onReady': onPlayerReady,
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerReady() {
        // Mute to satisfy autoplay policies across devices/browsers
        try { player.mute(); } catch (e) {}
        // Ensure iframe allows autoplay
        try {
            player.getIframe().setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
        } catch (e) {}
        (async () => {
            document.getElementById("status").textContent = "Ready";
            try { videoDurationSec = player.getDuration() || 0; } catch (e) {}
            try { await refreshUtcOffset(1); } catch (e) {}
            try {
                await refreshUtcOffset(2);
                await schedulePreciseStart();
            } catch (e) { try { syncToTarget(true); } catch (e2) {} }
            readyForWrites = true;
        })();
    }

    let hasInitialSynced = false;
    let pausedSinceLastPlay = false;
    let periodicSyncTimer = null;
    const SYNC_INTERVAL_MS = 200;
    const PAUSE_MIN_SEC = 0.01;      // use pause/resume above 10ms when ahead
    const MAX_PAUSE_STEP_SEC = 0.06; // cap each pause segment to 60ms
    const DRIFT_THRESHOLD_SEC = 0.25; // seek if beyond this and not using pause
    const MAJOR_DRIFT_SEC = 0.7;      // always correct immediately via seek
    const CORRECTION_COOLDOWN_MS = 1200;
    let lastCorrectionAt = 0;
    let pausePending = false;
    let pauseResumeRaf = 0;
    // Drift learning (use last correction to predict next)
    let lastDriftSec = null;
    let lastDriftTsMs = null;
    let skewSecPerSec = 0; // estimated drift slope (seconds drift per second)
    // Tight lock window for sub-10ms convergence
    let tightLockUntil = 0;
    let tightLockRaf = 0;
    const TIGHT_AHEAD_MIN_SEC = 0.005; // 5ms
    const TIGHT_BEHIND_MIN_SEC = 0.005; // 5ms
    async function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING) {
            const isInitial = !hasInitialSynced;
            if (isInitial || pausedSinceLastPlay) {
                syncToTarget(true);
                hasInitialSynced = true;
                pausedSinceLastPlay = false;
                document.getElementById("status").textContent = isInitial ? "Synced on join" : "Resynced after resume";
            }
            hideOverlay();
            if (!periodicSyncTimer) {
                periodicSyncTimer = setInterval(periodicSyncAdjust, SYNC_INTERVAL_MS);
            }
            startTightLockWindow(7000);
        } else if (event.data === YT.PlayerState.PAUSED) {
            pausedSinceLastPlay = true;
            if (periodicSyncTimer) { clearInterval(periodicSyncTimer); periodicSyncTimer = null; }
        } else if (event.data === YT.PlayerState.UNSTARTED) {
            // Some browsers report UNSTARTED if autoplay is blocked
            showOverlay();
        }
    }

    // Initial world time sync
    (async () => {
        await refreshUtcOffset(6);
    })();

    // Autoplay helpers
    function isPlaying() {
        try { return player && player.getPlayerState && player.getPlayerState() === YT.PlayerState.PLAYING; } catch (e) { return false; }
    }
    function attemptAutoplay() {
        try { player.playVideo(); } catch (e) {}
        setTimeout(() => { if (!isPlaying()) showOverlay(); }, 1200);
    }
    function showOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'flex';
    }
    function hideOverlay() {
        const ov = document.getElementById('autoplayOverlay');
        if (ov) ov.style.display = 'none';
    }
    document.getElementById('startPlayback').addEventListener('click', async () => {
        hideOverlay();
        if (mode === 'yt') {
            try { await schedulePreciseStart(); startTightLockWindow(7000); } catch { try { player.playVideo(); } catch (e) {} }
        } else {
            try { video.play(); } catch {}
        }
    });

    // UTC link-based sync and countdown removed for minimal setup

    // Stateless, UTC-based target and periodic drift correction
    function effectiveUtcMs() { return nowUtcMs(); }
    function computeUtcTargetPositionSec() {
        const dur = Number(periodSecParam || videoDurationSec) || 0;
        if (dur <= 0) return 0;
        const pos = ((effectiveUtcMs() - anchorMs) / 1000) % dur;
        return Math.max(0, Math.min(dur - 0.2, pos));
    }
    async function schedulePreciseStart() {
        // Pause, compute a start moment ~600ms in future, seek to that position, then resume precisely
        try { player.pauseVideo(); } catch {}
        const dur = Number(periodSecParam || videoDurationSec) || 0;
        if (dur <= 0) { attemptAutoplay(); return; }
        const resumeAtUtcMs = nowUtcMs() + 600;
        const resumePos = ((resumeAtUtcMs - anchorMs) / 1000) % dur;
        try { player.seekTo(resumePos, true); } catch {}
        // coarse wait then fine spin
        const coarseDelay = Math.max(0, resumeAtUtcMs - nowUtcMs() - 40);
        await new Promise(r => setTimeout(r, coarseDelay));
        const step = () => {
            if (nowUtcMs() >= resumeAtUtcMs - 5) {
                try { player.playVideo(); } catch {}
            } else {
                requestAnimationFrame(step);
            }
        };
        requestAnimationFrame(step);
    }
    function syncToTarget(force = false) {
        const target = computeUtcTargetPositionSec();
        let current = 0;
        try { current = player.getCurrentTime ? player.getCurrentTime() : 0; } catch (e) { current = 0; }
        const drift = target - current; // signed seconds (positive => behind)
        const absDrift = Math.abs(drift);
        const nowTs = performance.now();
        // Update skew estimate from last observation
        if (lastDriftTsMs != null) {
            const dtSec = Math.max(0.01, (nowTs - lastDriftTsMs) / 1000);
            const rate = (drift - (lastDriftSec ?? drift)) / dtSec;
            // Smooth with small learning rate to avoid noise
            skewSecPerSec = 0.9 * skewSecPerSec + 0.1 * rate;
        }
        lastDriftSec = drift;
        lastDriftTsMs = nowTs;
        const recentlyCorrected = (nowTs - lastCorrectionAt) < CORRECTION_COOLDOWN_MS;

        // Major corrections: single seek
        if (force || absDrift >= MAJOR_DRIFT_SEC || (!recentlyCorrected && absDrift >= DRIFT_THRESHOLD_SEC)) {
            try { player.seekTo(target, true); } catch (e) {}
            lastCorrectionAt = nowTs;
            if (!force) document.getElementById('status').textContent = `Corrected drift (${absDrift.toFixed(3)}s)`;
            return;
        }

        // If ahead (current > target), pause until target catches up to current
        if (!recentlyCorrected && drift < -PAUSE_MIN_SEC && !pausePending) {
            pauseUntilCatchUp(-drift);
            lastCorrectionAt = nowTs;
            return;
        }
        // If behind a bit, avoid seeks (YT keyframe granularity causes big jumps). Let the ahead instance pause.
        // Do nothing here; major drifts still handled above.
    }
    function pauseUntilCatchUp(waitSec) {
        pausePending = true;
        try { player.pauseVideo(); } catch (e) {}
        const resumeAtUtcMs = nowUtcMs() + Math.min(waitSec, MAX_PAUSE_STEP_SEC) * 1000;
        // Coarse timer then fine rAF spin to hit within ~10-20ms
        const coarseDelay = Math.max(0, waitSec * 1000 - 40);
        setTimeout(() => {
            const step = () => {
                if (nowUtcMs() >= resumeAtUtcMs - 5) {
                    try { player.playVideo(); } catch (e) {}
                    pausePending = false;
                    if (pauseResumeRaf) cancelAnimationFrame(pauseResumeRaf);
                    pauseResumeRaf = 0;
                } else {
                    pauseResumeRaf = requestAnimationFrame(step);
                }
            };
            pauseResumeRaf = requestAnimationFrame(step);
        }, coarseDelay);
    }
    function periodicSyncAdjust() { syncToTarget(false); }

    function startTightLockWindow(durationMs) {
        tightLockUntil = performance.now() + Math.max(1000, durationMs || 5000);
        if (tightLockRaf) cancelAnimationFrame(tightLockRaf);
        const step = () => {
            if (performance.now() > tightLockUntil) { tightLockRaf = 0; return; }
            // Run a tighter correction loop
            try {
                const dur = Number(periodSecParam || videoDurationSec) || 0;
                if (dur > 0) {
                    const target = computeUtcTargetPositionSec();
                    const current = player.getCurrentTime ? player.getCurrentTime() : 0;
                    const drift = target - current;
                    const absDrift = Math.abs(drift);
                    if (absDrift <= 0.01) { // within 10ms => stop early
                        tightLockRaf = 0; return;
                    }
                    if (drift < -TIGHT_AHEAD_MIN_SEC && !pausePending) {
                        pauseUntilCatchUp(-drift);
                        lastCorrectionAt = performance.now();
                    } else if (drift > TIGHT_BEHIND_MIN_SEC) {
                        // Avoid tiny seeks when behind; rely on the other instance pausing
                    }
                }
            } catch {}
            tightLockRaf = requestAnimationFrame(step);
        };
        tightLockRaf = requestAnimationFrame(step);
    }

    // No shared state writes; synchronization is derived from UTC

    // Optional native <video> high-precision mode
    if (mode === 'native') {
        const host = document.getElementById('player');
        const video = document.createElement('video');
        video.id = 'video';
        video.controls = true;
        video.playsInline = true;
        video.preload = 'auto';
        video.style.maxWidth = '100%';
        video.style.width = '100%';
        video.style.background = '#000';
        if (nativeSrc) {
            const src = document.createElement('source');
            src.src = nativeSrc;
            src.type = 'video/mp4';
            video.appendChild(src);
        }
        host.appendChild(video);

        let hasStarted = false;
        const TARGET_TOLERANCE_SEC = 0.01;
        const SEEK_THRESHOLD_SEC = 0.35;
        const MAX_RATE_DELTA = 0.03;
        const KP = 0.7;
        const KI = 0.06;
        let integralError = 0;
        let lastFrameTs = 0;

        function wrapErrorToPeriod(err, periodSec) {
            if (periodSec <= 0) return err;
            return ((err + periodSec / 2) % periodSec + periodSec) % periodSec - periodSec / 2;
        }
        function computeTargetPosSecNative() {
            const period = Number(periodSecParam || videoDurationSec) || 0;
            if (period <= 0) return 0;
            const utcSec = (nowUtcMs() - anchorMs) / 1000;
            const pos = ((utcSec % period) + period) % period;
            return Math.max(0, Math.min(period - 0.05, pos));
        }
        function applyRateNative(rate) { try { video.playbackRate = rate; } catch {} }
        function controllerStep(now) {
            if (!videoDurationSec) return scheduleNextFrame();
            const period = Number(periodSecParam || videoDurationSec) || 0;
            const current = video.currentTime || 0;
            const target = computeTargetPosSecNative();
            let error = wrapErrorToPeriod(target - current, period);
            const dt = lastFrameTs ? Math.max(0.005, (now - lastFrameTs) / 1000) : 0.016;
            lastFrameTs = now;

            if (Math.abs(error) >= SEEK_THRESHOLD_SEC) {
                try { video.currentTime = target; } catch {}
                applyRateNative(1.0);
                integralError = 0;
                document.getElementById('status').textContent = `Corrected drift (${Math.abs(error).toFixed(3)}s)`;
                return scheduleNextFrame();
            }

            integralError = Math.max(-1.0, Math.min(1.0, integralError + error * dt));
            const control = KP * error + KI * integralError;
            const desiredRate = Math.max(1 - MAX_RATE_DELTA, Math.min(1 + MAX_RATE_DELTA, 1 + control));
            if (Math.abs(error) <= TARGET_TOLERANCE_SEC) applyRateNative(1.0); else applyRateNative(desiredRate);
            scheduleNextFrame();
        }
        function scheduleNextFrame() {
            if (video.requestVideoFrameCallback) video.requestVideoFrameCallback(controllerStep);
            else setTimeout(() => controllerStep(performance.now()), 16);
        }
        video.addEventListener('loadedmetadata', async () => {
            videoDurationSec = Number(video.duration) || 0;
            document.getElementById('status').textContent = 'Ready';
            try { await refreshUtcOffset(2); } catch {}
            try { video.currentTime = computeTargetPosSecNative(); } catch {}
            try { await video.play(); } catch { showOverlay(); }
            if (!hasStarted) { hasStarted = true; scheduleNextFrame(); }
        });
        video.addEventListener('play', () => { if (!hasStarted) { hasStarted = true; scheduleNextFrame(); } });
        video.addEventListener('ended', () => { applyRateNative(1.0); });
    } else {
        // Load YouTube API if using yt mode
        let tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        document.body.appendChild(tag);
    }
</script>

</body>
</html>
